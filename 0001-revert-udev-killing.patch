From 2b3509a898dcb65d6fba41f3c9cd484b00730017 Mon Sep 17 00:00:00 2001
From: Michal Schmidt <mschmidt@redhat.com>
Date: Thu, 15 Nov 2012 16:55:09 +0100
Subject: [PATCH] revert udev killing

revert of upstream commit 194bbe33382f5365be3865ed1779147cb680f1d3
---
 src/udev/udevd.c | 32 ++++++++++++++++----------------
 1 file changed, 16 insertions(+), 16 deletions(-)

diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index ebd601e..53322b0 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -74,7 +74,6 @@ static int exec_delay;
 static sigset_t sigmask_orig;
 static UDEV_LIST(event_list);
 static UDEV_LIST(worker_list);
-char *udev_cgroup;
 static bool udev_exit;
 
 enum event_state {
@@ -453,13 +452,22 @@ static int event_queue_insert(struct udev_device *dev)
         return 0;
 }
 
-static void worker_kill(struct udev *udev)
+static void worker_kill(struct udev *udev, int retain)
 {
         struct udev_list_node *loop;
+        int max;
+
+        if (children <= retain)
+                return;
+
+        max = children - retain;
 
         udev_list_node_foreach(loop, &worker_list) {
                 struct worker *worker = node_to_worker(loop);
 
+                if (max-- <= 0)
+                        break;
+
                 if (worker->state == WORKER_KILLED)
                         continue;
 
@@ -631,7 +639,7 @@ static struct udev_ctrl_connection *handle_ctrl_msg(struct udev_ctrl *uctrl)
                 log_debug("udevd message (SET_LOG_PRIORITY) received, log_priority=%i\n", i);
                 log_set_max_level(i);
                 udev_set_log_priority(udev, i);
-                worker_kill(udev);
+                worker_kill(udev, 0);
         }
 
         if (udev_ctrl_get_stop_exec_queue(ctrl_msg) > 0) {
@@ -673,7 +681,7 @@ static struct udev_ctrl_connection *handle_ctrl_msg(struct udev_ctrl *uctrl)
                         }
                         free(key);
                 }
-                worker_kill(udev);
+                worker_kill(udev, 0);
         }
 
         i = udev_ctrl_get_set_children_max(ctrl_msg);
@@ -1198,10 +1206,6 @@ int main(int argc, char *argv[])
                         rc = 3;
                         goto exit;
                 }
-
-                /* get our own cgroup, we regularly kill everything udev has left behind */
-                if (cg_get_by_pid(SYSTEMD_CGROUP_CONTROLLER, 0, &udev_cgroup) < 0)
-                        udev_cgroup = NULL;
         } else {
                 /* open control and netlink socket */
                 udev_ctrl = udev_ctrl_new(udev);
@@ -1400,7 +1404,7 @@ int main(int argc, char *argv[])
 
                         /* discard queued events and kill workers */
                         event_queue_cleanup(udev, EVENT_QUEUED);
-                        worker_kill(udev);
+                        worker_kill(udev, 0);
 
                         /* exit after all has cleaned up */
                         if (udev_list_node_is_empty(&event_list) && udev_list_node_is_empty(&worker_list))
@@ -1408,13 +1412,9 @@ int main(int argc, char *argv[])
 
                         /* timeout at exit for workers to finish */
                         timeout = 30 * 1000;
-                } else if (udev_list_node_is_empty(&event_list) && !children) {
+                } else if (udev_list_node_is_empty(&event_list) && children <= 2) {
                         /* we are idle */
                         timeout = -1;
-
-                        /* cleanup possible left-over processes in our cgroup */
-                        if (udev_cgroup)
-                                cg_kill(SYSTEMD_CGROUP_CONTROLLER, udev_cgroup, SIGKILL, false, true, NULL);
                 } else {
                         /* kill idle or hanging workers */
                         timeout = 3 * 1000;
@@ -1435,7 +1435,7 @@ int main(int argc, char *argv[])
                         /* kill idle workers */
                         if (udev_list_node_is_empty(&event_list)) {
                                 log_debug("cleanup idle workers\n");
-                                worker_kill(udev);
+                                worker_kill(udev, 2);
                         }
 
                         /* check for hanging events */
@@ -1490,7 +1490,7 @@ int main(int argc, char *argv[])
 
                 /* reload requested, HUP signal received, rules changed, builtin changed */
                 if (reload) {
-                        worker_kill(udev);
+                        worker_kill(udev, 0);
                         rules = udev_rules_unref(rules);
                         udev_builtin_exit(udev);
                         reload = false;
-- 
1.7.11.7

